(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["metrics`",{"dsp`","general`"}]


computeAllISSI::usage=
"computeAllISSI[M,mode] takes as input a 4-by-4-by-N array, P, of length N transfer functions and returns a 2-by-6-by-N array, I, of inter sweet-spot isolation (ISSI) spectra (these are magnitude-squared spectra) assuming two binaural sweet-spots (i.e., each sweet-spot consists of binaural microphones that record incident sound waves). Specifically, P is a 4-by-4 matrix of transfer functions between 4 loudspeakers (columns) and 4 microphones (rows) split evenly across 2 sweet-spots (\"Driver\" and \"Passenger\" in some applications). Loudspeakers and mics. 1 (\"Left\") and 2 (\"Right\") are for sweet-spot 1 (\"Driver\"), and 3 (\"Left\") and 4 (\"Right\") are for sweet-spot 2 (\"Passenger\"). Similarly, I is a 2-by-6 matrix of magnitude-squared ISSI spectra where the two rows correspond to the two sweet-spots and the 6 columns correspond to the following:

Column 1 - ISSI computed between mics. 1 and 4 (also called \"Outer Ears\" for some applications)
Column 2 - ISSI computed between mics. 2 and 3 (\"Inner Ears\")
Column 3 - ISSI computed between mics. 1 and 3 (\"Left Ears\")
Column 4 - ISSI computed between mics. 2 and 4 (\"Right Ears\")
Column 5 - Per-frequency geometric mean (spectrum) across columns 1-4.
Column 6 - Per-frequency minimum (spectrum) across columns 1-4.

The second input, mode, can take the following values:
1. \"Correlated\" - Compute correlated ISSI (see addTFs function in dsp package).
2. \"Uncorrelated\" - Compute uncorrelated ISSI (see addTFs function in dsp package).
3. \"Minimum\" - Compute the per-frequency minimum (spectrum) of correlated and uncorrelated ISSI."

computeAllIPI::usage=
"computeAllIPI[M,mode] operates in exactly the same way as the computeAllISSI function but returns the transpose of the array returned by computeAllISSI. For more information, see the help for computeAllISSI. Note that IPI stands for \"inter program isolation.\""

computePointIPI::usage=
"computePointIPI[M,mode] takes as input either a 1-by-4-by-N array or a 4-by-N matrix of transfer functions and returns a 2-by-N matrix of (magnitude-squared) IPI (inter program isolation) spectra. If the input is a 1-by-4-by-N array, the array is squeezed down to a 4-by-N matrix. The 4 rows of the matrix correspond to 4 loudspeakers split evenly across 2 sweet-spots (\"Driver\" and \"Passenger\" in some applications). Loudspeakers 1 (\"Left\") and 2 (\"Right\") correspond to sweet-spot 1 (\"Driver\") and 3 (\"Left\") and 4 (\"Right\") to sweet-spot 2 (\"Passenger\"). The two rows of the output matrix correspond to the two sweet-spots. Point IPI spectra computed for sweet-spot 1 (or 2) correspond roughly to the ratio, at a point in space, of total acoustical energy from loudspeakers 1 (or 3) and 2 (or 4) to that from loudspeakers 3 (or 1) and 4 (or 2).

The second input, mode, takes the same values as described in the help for the computeAllISSI function."


Begin["`Private`"]


computeAllISSI[M_,mode_]:=Module[{specLen,ISSI,ISSIc,ISSIu},
(* Returns: {{Subscript[ISSI, O]^A, Subscript[ISSI, I]^A, Subscript[ISSI, L]^A, Subscript[ISSI, R]^A, Subscript[ISSI, Avg]^A, Subscript[ISSI, Min]^A},{Subscript[ISSI, O]^B, Subscript[ISSI, I]^B, Subscript[ISSI, L]^B, Subscript[ISSI, R]^B, Subscript[ISSI, Avg]^B, Subscript[ISSI, Min]^B}} *)
specLen = Dimensions[M][[3]];
ISSI = ConstantArray[0.,{2,6,specLen}];
If[mode=="Minimum",
ISSIc = computeAllISSI[M,"Correlated"];
ISSIu = computeAllISSI[M,"Uncorrelated"];
Do[ISSI[[ii,jj,kk]] = Min[ISSIc[[ii,jj,kk]],ISSIu[[ii,jj,kk]]];
,{ii,1,2},{jj,1,4},{kk,1,specLen}];
,
(* Outer Ears *)
ISSI[[1,1]] = addTFs[M[[1,1]],M[[1,2]],mode]/addTFs[M[[4,1]],M[[4,2]],mode];
ISSI[[2,1]] = addTFs[M[[4,3]],M[[4,4]],mode]/addTFs[M[[1,3]],M[[1,4]],mode];
(* Inner Ears *)
ISSI[[1,2]] = addTFs[M[[2,1]],M[[2,2]],mode]/addTFs[M[[3,1]],M[[3,2]],mode];
ISSI[[2,2]] = addTFs[M[[3,3]],M[[3,4]],mode]/addTFs[M[[2,3]],M[[2,4]],mode];
(* Left Ears *)
ISSI[[1,3]] = addTFs[M[[1,1]],M[[1,2]],mode]/addTFs[M[[3,1]],M[[3,2]],mode];
ISSI[[2,3]] = addTFs[M[[3,3]],M[[3,4]],mode]/addTFs[M[[1,3]],M[[1,4]],mode];
(* Right Ears *)
ISSI[[1,4]] = addTFs[M[[2,1]],M[[2,2]],mode]/addTFs[M[[4,1]],M[[4,2]],mode];
ISSI[[2,4]] = addTFs[M[[4,3]],M[[4,4]],mode]/addTFs[M[[2,3]],M[[2,4]],mode];
];
Do[
ISSI[[ii,5]] = GeometricMean[ISSI[[ii,1;;4]]];
ISSI[[ii,6]] = Min/@Transpose[ISSI[[ii,1;;4]]];
,{ii,1,2}];
ISSI
]

computeAllIPI[M_,mode_]:=computeAllISSI[Transpose[M],mode]
(* Returns: {{Subscript[IPI, O]^D, Subscript[IPI, I]^D, Subscript[IPI, L]^D, Subscript[IPI, R]^D, Subscript[IPI, Avg]^D, Subscript[IPI, Min]^D},{Subscript[IPI, O]^P, Subscript[IPI, I]^P, Subscript[IPI, L]^P, Subscript[IPI, R]^P, Subscript[IPI, Avg]^P, Subscript[IPI, Min]^p}} *)

computePointIPI[M_,mode_]:=Module[{specLen,IPI,IPIc,IPIu},
(* Returns: {Subscript[IPI, 0]^D,Subscript[IPI, 0]^P} *)
If[Dimensions[M][[1]]==1 && Dimensions[M][[2]]==4,
(* In case M is (1 x 4 x specLen) *)
IPI = computePointIPI[M[[1]],mode];
,
(* Otherwise, M is (4 x specLen) *)
specLen = Dimensions[M][[2]];
IPI = ConstantArray[0.,{2,specLen}];
If[mode=="Minimum",
IPIc = computePointIPI[M,"Correlated"];
IPIu = computePointIPI[M,"Uncorrelated"];
Do[IPI[[ii,kk]] = Min[IPIc[[ii,kk]],IPIu[[ii,kk]]];
,{ii,1,2},{kk,1,specLen}];
,
IPI[[1]] = addTFs[M[[1]],M[[2]],mode]/addTFs[M[[3]],M[[4]],mode];
IPI[[2]] = addTFs[M[[3]],M[[4]],mode]/addTFs[M[[1]],M[[2]],mode];
];
];
IPI
]


End[]


EndPackage[]

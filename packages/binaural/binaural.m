(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["binaural`",{"dsp`","general`"}]


lowFreqSHMITD::usage=
"lowFreqSHMITD[azimuthAngle] computes ITD applicable at low frequencies using an analytical formula derived from the low-frequency limiting solution to scattering of sound from a rigid sphere of radius 0.0875 m. lowFreqSHMITD[azimuthAngle,headRadius] optionally specifies a spherical head radius in meters for computing ITD. For more on the approach, see Kuhn (1977) - Model for the interaural time differences in the azimuthal plane."

highFreqSHMITD::usage=
"highFreqSHMITD[azimuthAngle] computes ITD applicable at high frequencies using the Woodworth and Schlosberg formula for a rigid sphere of radius 0.0875 m. highFreqSHMITD[azimuthAngle,headRadius] optionally specifies a spherical head radius in meters for computing ITD."

onsetITD::usage=
"onsetITD[inputHRIRLeft,inputHRIRRight] estimates ITD using a 20 percent threshold and returns ITD in seconds assuming a sampling rate of 44100 Hz.

OPTIONAL INPUTS:
	1. \"Resampling\" \[RightArrow] specifies the factor by which to resample the input IRs prior to estimating ITD.
	2. \"Threshold\" \[RightArrow] specifies the threshold percentage to use.
	3. \"Sampling Rate\" \[RightArrow] specifies the sampling rate of the input IRs in Hz."

phaseDelayDifferenceITD::usage=
"phaseDelayDifferenceITD[inputHRIRLeft,inputHRIRRight] accepts two one-dimensional lists corresponding to the left and right HRIRs for a given individual and spatial location and computes the ITD, in seconds, as a difference in phase delays of the two IRs averaged from 0 to 0.5 kHz assuming a sampling rate of 44.1 kHz. The phase response of each IR is unwrapped with a tolerance of \[Pi] rad before ITD computation.

OPTIONAL INPUTS:
	1. \"Resampling\" \[RightArrow] specifies the factor by which to resample the input IRs prior to estimating ITD.
	2. \"Averaged\" \[RightArrow] specifies whether or not to average over frequency to return a single value, or to return a spectrum. The options are True or False.
	3. \"Averaging Range\" \[RightArrow] specifies the range over which averaging is performed. This is applicable only if the Averaged option is set to True. The range is specified as {lower limit, upper limit} with both limits specified in kHz.
	4. \"Sampling Rate\" \[RightArrow] specifies the sampling rate of the input IRs in Hz."

groupDelayDifferenceITD::usage=
"groupDelayDifferenceITD[inputHRIRLeft,inputHRIRRight] accepts two one-dimensional lists corresponding to the left and right HRIRs for a given individual and spatial location and computes the ITD, in seconds, as a difference in group delays of the two IRs averaged from 0 to 0.5 kHz assuming a sampling rate of 44.1 kHz.

OPTIONAL INPUTS:
	1. \"Resampling\" \[RightArrow] specifies the factor by which to resample the input IRs prior to estimating ITD.
	2. \"Averaged\" \[RightArrow] specifies whether or not to average over frequency to return a single value, or to return a spectrum. The options are True or False.
	3. \"Averaging Range\" \[RightArrow] specifies the range over which averaging is performed. This is applicable only if the Averaged option is set to True. The range is specified as {lower limit, upper limit} with both limits specified in kHz.
	4. \"Sampling Rate\" \[RightArrow] specifies the sampling rate of the input IRs in Hz."

maxXCorrITD::usage=
"maxXCorrITD[inputHRIRLeft,inputHRIRRight] accepts two one-dimensional lists corresponding to the left and right HRIRs for a given individual and spatial location and computes the ITD, in seconds, as a deviation from zero seconds where the maximum of the cross-correlation of the left and right HRIRs occurs assuming a sampling rate of 44.1 kHz.

OPTIONAL INPUTS:
	1. \"Resampling\" \[RightArrow] specifies the factor by which to resample the input IRs prior to estimating ITD.
	2. \"Sampling Rate\" \[RightArrow] specifies the sampling rate of the input IRs in Hz."

pinnaSpectralNotches::usage=
"pinnaSpectralNotches[inputHRIR] identifies notches caused by the pinna in the magnitude spectrum corresponding to inputHRIR and returns the notch frequencies and their sample positions. For more on the algorithm used, see Raykar et al. (2005) - Extracting the frequencies of the pinna spectral notches in measured HRIRs.

OPTIONAL INPUTS:
	1. \"Order\" \[RightArrow] specifies linear prediction residual order (default = 12).
	2. \"Sampling Rate\" \[RightArrow] specifies the sampling rate in Hz (default = 44100)."

smoothHRTFLogMagSpec::usage=
"smoothHRTFLogMagSpec[inputHRIR] smooths the log-magnitude spectrum corresponding to inputHRIR and returns the smoothed, minimum-phase version of inputHRIR. For more on the algorithm used, see Kulkarni and Colburn (1998) - Role of spectral detail in sound localization.

OPTIONAL INPUTS:
	1. \"Smoothing Factor\" \[RightArrow] specifies the smoothing factor to use. Values range between 0 (max. smoothing) and 1 (no smoothing). The default value is 0.2."

windowIRPair::usage=
"windowIRPair[IRL,IRR,Fs] windows a pair of IRs specified at sampling rate Fs (in Hz). The default window parameters are: 1) Duration - 0.01 seconds, 2) Pre-onset delay - 0.001 seconds, 3) Window type - \"Tukey\". The windowing is performed such that the window for each IR is applied starting at \"Pre-onset delay\" samples before the onset of that IR, followed by appropriate zero padding to retain the relative delay between the IRs. windowIRPair[IRL,IRR,Fs,windowDuration] optionally specifies the window duration in seconds. windowIRPair[IRL,IRR,Fs,windowDuration,preOnsetDelay] optionally specifies the pre-onset delay in seconds. windowIRPair[IRL,IRR,Fs,windowDuration,preOnsetDelay,winType] optionally specifies the window type. The two options are: 1) \"Rect\" - rectangular window and 2) \"Tukey\" - Tukey window. windowIRPair[IRL,IRR,Fs,windowDuration,preOnsetDelay,winType,keepOnsetFlag] optionally specifies whether or not to retain the absolute onsets of the original IRs. If set to True (default), the original onsets are retained. If set to False, the minimum onset of the windowed IRs is set to 1 sample (excluding any pre-onset delay), with the other windowed IR appropriately shifted to retain the relative delays between IRs. windowIRPair[IRL,IRR,Fs,windowDuration,preOnsetDelay,winType,keepOnsetFlag,keepLenFlag] optionally specifies whether or not the windowed IRs should have a length of windowDuration (set keepLenFlag to True - default) or the length of the original, input IRs (keepLenFlag = False)."


Begin["`Private`"]


lowFreqSHMITD[azimuthAngle_,headRadius_: 0.0875]:=Module[
{azimuthAngleList,computedITDList,computedITD,soundSpeed=343}
,
If[ListQ[azimuthAngle],
azimuthAngleList=azimuthAngle;
,
azimuthAngleList=List[azimuthAngle];
];
computedITDList=(3. headRadius Sin[azimuthAngleList])/soundSpeed;
If[ListQ[azimuthAngle],
computedITD=computedITDList;
,
computedITD=computedITDList[[1]];
];
computedITD
]

highFreqSHMITD[azimuthAngleRad_,headRadiusMeter_: 0.0875]:=Module[
{azimuthAngleListRad,azimuthAngleListLen,computedITDListSec,computedITDSec,soundSpeed=343}
,
If[ListQ[azimuthAngleRad],
azimuthAngleListRad=azimuthAngleRad;
,
azimuthAngleListRad=List[azimuthAngleRad];
];
azimuthAngleListLen=Length[azimuthAngleListRad];
computedITDListSec=headRadiusMeter (Sin[azimuthAngleListRad]+azimuthAngleListRad)/soundSpeed ;
If[ListQ[azimuthAngleRad],
computedITDSec=computedITDListSec;
,
computedITDSec=computedITDListSec[[1]];
];
computedITDSec
]

Options[onsetITD]={"Resampling"->1.,"Threshold"->20.,"Sampling Rate"->44100.};
onsetITD[inputHRIRLeft_,inputHRIRRight_,OptionsPattern[]]:=Module[
{resampleFactor,thresholdPercent,leftOnsetSample,rightOnsetSample,thresholdITDSec}
,
resampleFactor=OptionValue["Resampling"];
thresholdPercent=OptionValue["Threshold"];
leftOnsetSample= signalOnset[inputHRIRLeft,"Threshold"->thresholdPercent,"Resampling"->resampleFactor];
rightOnsetSample = signalOnset[inputHRIRRight,"Threshold"->thresholdPercent,"Resampling"->resampleFactor];
thresholdITDSec = 1./(resampleFactor OptionValue["Sampling Rate"]) (leftOnsetSample-rightOnsetSample)
]

Options[phaseDelayDifferenceITD]={"Averaged"->True,"Averaging Range"->{0.,0.5},"Resampling"->1.,"Sampling Rate"->44100.};
phaseDelayDifferenceITD[inputHRIRLeft_,inputHRIRRight_,OptionsPattern[]]:=Module[
{resampleFactor,samplingRate,averageITDFlag,averageRange,interpolatedHRIRLeft,interpolatedHRIRRight,interpolatedHRIRLen,phaseLeftRad,phaseRightRad,freqListHz,averagingFreqIndex,lfSampleIndex,hfSampleIndex,phaseDelayDifferenceITDSec,upsampledPhaseDelayDifferenceITDSec}
,
resampleFactor=OptionValue["Resampling"];
samplingRate=OptionValue["Sampling Rate"];
averageITDFlag=OptionValue["Averaged"];
averageRange=OptionValue["Averaging Range"];
interpolatedHRIRLeft=resample[inputHRIRLeft,1.,resampleFactor];
interpolatedHRIRRight=resample[inputHRIRRight,1.,resampleFactor];
interpolatedHRIRLen=Length[interpolatedHRIRLeft];
phaseLeftRad=unwrapPhase[Arg[IRtoTF[interpolatedHRIRLeft]]];
phaseRightRad=unwrapPhase[Arg[IRtoTF[interpolatedHRIRRight]]];
freqListHz=freqList[interpolatedHRIRLen,resampleFactor samplingRate];
If[averageITDFlag,
averagingFreqIndex=IntegerPart[(2./interpolatedHRIRLen+(averageRange 1000.)/(resampleFactor samplingRate)) interpolatedHRIRLen];
lfSampleIndex=averagingFreqIndex[[1]];
hfSampleIndex=averagingFreqIndex[[2]];
phaseDelayDifferenceITDSec=(1./(hfSampleIndex-lfSampleIndex)) Total[(phaseRightRad[[lfSampleIndex;;hfSampleIndex]]-phaseLeftRad[[lfSampleIndex;;hfSampleIndex]])/(2. N[\[Pi]] freqListHz[[lfSampleIndex;;hfSampleIndex]])];
,
upsampledPhaseDelayDifferenceITDSec=N[(phaseRightRad-phaseLeftRad)/(2. N[\[Pi]] freqListHz)];
phaseDelayDifferenceITDSec=Downsample[upsampledPhaseDelayDifferenceITDSec,resampleFactor];
];
phaseDelayDifferenceITDSec
]

Options[groupDelayDifferenceITD]={"Averaged"->True,"Averaging Range"->{0.,0.5},"Resampling"->1.,"Sampling Rate"->44100.};
groupDelayDifferenceITD[inputHRIRLeft_,inputHRIRRight_,OptionsPattern[]]:= Module[
{resampleFactor,sampleRateHz,averageITD,averagingFreqRangekHz,interpolatedHRIRLeft,interpolatedHRIRRight,interpolatedHRIRLen,groupDelayLeftSample, groupDelayRightSample,averagingFreqSampleIndex,lfSampleIndex,hfSampleIndex,groupDelayDifferenceITDSec,upsampledGroupDelayDifferenceITDSec}
,
resampleFactor=OptionValue["Resampling"];
sampleRateHz=OptionValue["Sampling Rate"];
averageITD=OptionValue["Averaged"];
averagingFreqRangekHz=OptionValue["Averaging Range"];
interpolatedHRIRLeft=resample[inputHRIRLeft,1.,resampleFactor];
interpolatedHRIRRight=resample[inputHRIRRight,1.,resampleFactor];
interpolatedHRIRLen=Length[interpolatedHRIRLeft];
groupDelayLeftSample=groupDelaySpec[interpolatedHRIRLeft];
groupDelayRightSample=groupDelaySpec[interpolatedHRIRRight];
If[averageITD,
averagingFreqSampleIndex=IntegerPart[(1./interpolatedHRIRLen+(averagingFreqRangekHz 1000.)/(resampleFactor sampleRateHz))interpolatedHRIRLen];
lfSampleIndex=averagingFreqSampleIndex[[1]];
hfSampleIndex=averagingFreqSampleIndex[[2]];
groupDelayDifferenceITDSec=N[(1/(hfSampleIndex-lfSampleIndex) Total[groupDelayLeftSample[[lfSampleIndex;;hfSampleIndex]]-groupDelayRightSample[[lfSampleIndex;;hfSampleIndex]]]) (1./(resampleFactor sampleRateHz))];
,(* ELSE *)
upsampledGroupDelayDifferenceITDSec=N[(groupDelayLeftSample-groupDelayRightSample)/(resampleFactor sampleRateHz)];
groupDelayDifferenceITDSec=Downsample[upsampledGroupDelayDifferenceITDSec,resampleFactor];
];
groupDelayDifferenceITDSec
]

Options[maxXCorrITD]={"Resampling"->1.,"Sampling Rate"->44100.};
maxXCorrITD[inputHRIRLeft_,inputHRIRRight_,OptionsPattern[]]:=Module[
{resampleFactor,sampleRateHz,interpolatedHRIRLeft,interpolatedHRIRRight,leftHRIREnergy,rightHRIREnergy,normalizationFactor,normalizedCrossCorrelationLRList,normalizedCrossCorrelationRLList,maxPosLR,maxPosRL,samplesITD,maxCrossCorrelationITDSec}
,
resampleFactor=OptionValue["Resampling"];
sampleRateHz=OptionValue["Sampling Rate"];
interpolatedHRIRLeft=resample[inputHRIRLeft,1.,resampleFactor];
interpolatedHRIRRight=resample[inputHRIRRight,1.,resampleFactor];
leftHRIREnergy = ListCorrelate[interpolatedHRIRLeft,interpolatedHRIRLeft,{1,1}][[1]];
rightHRIREnergy = ListCorrelate[interpolatedHRIRRight,interpolatedHRIRRight,{1,1}][[1]];
normalizationFactor=Sqrt[leftHRIREnergy rightHRIREnergy];
normalizedCrossCorrelationLRList = ListCorrelate[interpolatedHRIRLeft,interpolatedHRIRRight,{1,1}]/normalizationFactor;
normalizedCrossCorrelationRLList = ListCorrelate[interpolatedHRIRRight,interpolatedHRIRLeft,{1,1}]/normalizationFactor;
maxPosLR = Position[normalizedCrossCorrelationLRList,Max[normalizedCrossCorrelationLRList]][[1,1]];
maxPosRL = Position[normalizedCrossCorrelationRLList,Max[normalizedCrossCorrelationRLList]][[1,1]];
samplesITD=Min[maxPosLR,maxPosRL];
If[maxPosLR>=maxPosRL,maxCrossCorrelationITDSec=1./(resampleFactor sampleRateHz) (samplesITD-1.);
, (* ELSE *)
maxCrossCorrelationITDSec=-(1./(resampleFactor sampleRateHz))(samplesITD-1.);
];
maxCrossCorrelationITDSec
]

Options[pinnaSpectralNotches]={"Order"->12,"Sampling Rate"->44100.};
pinnaSpectralNotches[inputHRIR_]:=Module[
{onsetSamp,inputIRLen,shiftIR,lpResOrder,lpResIR,fS,winLen,halfHannWin,winLPRes,acf,winAutoCorrFunc,grpDelFunc,fVec,nyqSamp,grpDelFuncFlip,specNotchSamps,specNotchFreqs}
,
onsetSamp=signalOnset[inputHRIR];
inputIRLen=Length[inputHRIR];
shiftIR=PadRight[inputHRIR[[onsetSamp;;]],inputIRLen,0.];
lpResOrder=OptionValue["Order"];
fS=OptionValue["Sampling Rate"];
lpResIR=lpResidual[shiftIR,lpResOrder];
winLen=Round[fS/1000.];
halfHannWin=PadRight[raisedCosWin[winLen,{0,1}],inputIRLen,0.];
winLPRes=lpResIR halfHannWin;
acf=autoCorrFunc[winLPRes];
winAutoCorrFunc=acf halfHannWin;
grpDelFunc=groupDelaySpec[winAutoCorrFunc];
grpDelFuncFlip=Mean[grpDelFunc]-grpDelFunc;
nyqSamp=Ceiling[(inputIRLen+1)/2];
specNotchSamps=PeakDetect[grpDelFuncFlip[[;;nyqSamp]],0,0,-\[Infinity]];
fVec=freqList[inputIRLen,fS];
specNotchFreqs=Pick[fVec[[;;nyqSamp]],specNotchSamps,1];
{specNotchFreqs,Pick[Range[nyqSamp],specNotchSamps,1]}
]

Options[smoothHRTFLogMagSpec]={"Smoothing Factor"->0.2};
smoothHRTFLogMagSpec[inputHRIR_]:=Module[
{inputHRTF,inputHRTFLen,inputHRTFNyqLen, logMagHRTF,alpha,fourierSeriesCoeffs,smoothingFactor,smoothingIndex,smoothedHRTFHalf,smoothedHRTF,zeroPhIR,minPhIR}
,
inputHRTF=IRtoTF[inputHRIR];
inputHRTFLen=Length[inputHRTF];
inputHRTFNyqLen = Ceiling[(inputHRTFLen+1)/2];
logMagHRTF=Log10[Abs[inputHRTF]];
alpha = Join[{0.5},ConstantArray[1.,inputHRTFNyqLen-2],{0.5}];
fourierSeriesCoeffs=2 alpha (1./Sqrt[2.(inputHRTFNyqLen-1.)]) FourierDCT[logMagHRTF[[;;inputHRTFNyqLen]],1];
smoothingFactor=OptionValue["Smoothing Factor"];
smoothingIndex=IntegerPart[smoothingFactor inputHRTFNyqLen];
smoothingIndex=Clip[smoothingIndex,{1,inputHRTFNyqLen}];
smoothedHRTFHalf=Table[Total[fourierSeriesCoeffs[[;;smoothingIndex]] Cos[(2.N[\[Pi]] (ii-1.))/inputHRTFLen Range[0.,smoothingIndex-1.]]],{ii,inputHRTFNyqLen}];
smoothedHRTF=10.^(Join[smoothedHRTFHalf,Drop[Reverse[Drop[smoothedHRTFHalf,1]],1]]);
zeroPhIR=TFtoIR[smoothedHRTF];
minPhIR=PadRight[getMinimumPhaseIR[zeroPhIR],Length[inputHRIR],0.]
]

windowIRPair[IRL_,IRR_,Fs_,windowDuration_:0.01,preOnsetDelay_:0.001,winType_:"Tukey",keepOnsetFlag_: True,keepLenFlag_:True]:=Module[{irL,irR,IRLen,winLen,maxOnset,effWinLen,preOnsetDelaySamp,preOnsetDelaySec,winVec,onsetL,onsetR,onsetMin,tempIRL,tempIRR,startIndx,stopIndx,outIRL,outIRR},
IRLen = Length[IRL];
winLen = Round[Fs windowDuration];
onsetL = signalOnset[IRL,"Threshold"->20.];
onsetR = signalOnset[IRR,"Threshold"->20.];
maxOnset=Max[onsetL,onsetR];
If[keepLenFlag,
effWinLen=winLen-maxOnset;
,
effWinLen=winLen;
];
If[IRLen<(effWinLen+maxOnset),
irL=PadRight[IRL,effWinLen+maxOnset,0.];
irR=PadRight[IRR,effWinLen+maxOnset,0.];
IRLen=effWinLen+maxOnset;
,
irL=IRL;
irR=IRR;
];

preOnsetDelaySamp = Round[Fs preOnsetDelay];
onsetMin=Min[onsetL,onsetR];
If[preOnsetDelaySamp>=onsetMin,
preOnsetDelaySamp=onsetMin-1;
preOnsetDelaySec=preOnsetDelaySamp/Fs;
,
preOnsetDelaySec=preOnsetDelaySamp/Fs;
];
Switch[winType
,"Rect",
winVec = ConstantArray[1.,effWinLen];
,"Tukey",
winVec =tukeyWin[effWinLen,(2.preOnsetDelaySec)/(effWinLen/Fs)];
,_,
MessageDialog["Unrecognized input. Aborting..."];
Abort[];
];
startIndx=onsetL-preOnsetDelaySamp+1;
stopIndx=startIndx+effWinLen-1;
tempIRL=PadRight[irL[[startIndx;;stopIndx]]winVec,IRLen,0.];
startIndx=onsetR-preOnsetDelaySamp+1;
stopIndx=startIndx+effWinLen-1;
tempIRR=PadRight[irR[[startIndx;;stopIndx]]winVec,IRLen,0.];
Switch[keepOnsetFlag
,False,
If[onsetL>=onsetR,
outIRL = RotateRight[tempIRL,onsetL-onsetR];
outIRR = tempIRR;
,
outIRL = tempIRL;
outIRR = RotateRight[tempIRR,onsetR-onsetL];
];
,True,
outIRL=RotateRight[tempIRL,onsetL-preOnsetDelaySamp];
outIRR=RotateRight[tempIRR,onsetR-preOnsetDelaySamp];
,_,
MessageDialog["Unrecognized input. Aborting..."];
Abort[];
];
If[keepLenFlag,
outIRL=outIRL[[;;winLen]];
outIRR=outIRR[[;;winLen]];
];
{outIRL,outIRR}
]


End[]


EndPackage[]

(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["binaural`",{"dsp`"}]


lowFreqSHMITD::usage="lowFreqSHMITD[azimuthAngle,headRadius] computes ITD applicable at low frequencies using an analytical formula derived from the low-frequency limiting solution to scattering of sound from a rigid sphere of radius 0.0875 m.

OPTIONAL INPUTS:
	1. headRadius \[RightArrow] specifies the spherical head radius in metres.
REF:
	Kuhn (1977) - Model for the interaural time differences in the azimuthal plane."

highFreqSHMITD::usage="highFreqSHMITD[azimuthAngle,headRadius] computes ITD applicable at high frequencies using the Woodworth and Schlosberg formula for a rigid sphere of radius 0.0875 m.

OPTIONAL INPUTS:
	1. headRadius \[RightArrow] specifies the spherical head radius in metres."

onsetITD::usage=
"onsetITD[inputHRIRLeft,inputHRIRRight] estimates ITD using a 20 percent threshold and returns ITD in seconds assuming a sampling rate of 44100 Hz.

OPTIONAL INPUTS:
	1. \"Resampling\" \[RightArrow] specifies the factor by which to resample the input IRs prior to estimating ITD.
	2. \"Threshold\" \[RightArrow] specifies the threshold percentage to use.
	3. \"Sampling Rate\" \[RightArrow] specifies the sampling rate of the input IRs in Hz."

phaseDelayDifferenceITD::usage=
"phaseDelayDifferenceITD[inputHRIRLeft,inputHRIRRight] accepts two one-dimensional lists corresponding to the left and right HRIRs for a given individual and spatial location and computes the ITD, in seconds, as a difference in phase delays of the two IRs averaged from 0 to 0.5 kHz assuming a sampling rate of 44.1 kHz. The phase response of each IR is unwrapped with a tolerance of \[Pi] rad before ITD computation.

OPTIONAL INPUTS:
	1. \"Resampling\" \[RightArrow] specifies the factor by which to resample the input IRs prior to estimating ITD.
	2. \"Averaged\" \[RightArrow] specifies whether or not to average over frequency to return a single value, or to return a spectrum. The options are True or False.
	3. \"Averaging Range\" \[RightArrow] specifies the range over which averaging is performed. This is applicable only if the Averaged option is set to True. The range is specified as {lower limit, upper limit} with both limits specified in kHz.
	4. \"Sampling Rate\" \[RightArrow] specifies the sampling rate of the input IRs in Hz."

groupDelayDifferenceITD::usage=
"groupDelayDifferenceITD[inputHRIRLeft,inputHRIRRight] accepts two one-dimensional lists corresponding to the left and right HRIRs for a given individual and spatial location and computes the ITD, in seconds, as a difference in group delays of the two IRs averaged from 0 to 0.5 kHz assuming a sampling rate of 44.1 kHz.

OPTIONAL INPUTS:
	1. \"Resampling\" \[RightArrow] specifies the factor by which to resample the input IRs prior to estimating ITD.
	2. \"Averaged\" \[RightArrow] specifies whether or not to average over frequency to return a single value, or to return a spectrum. The options are True or False.
	3. \"Averaging Range\" \[RightArrow] specifies the range over which averaging is performed. This is applicable only if the Averaged option is set to True. The range is specified as {lower limit, upper limit} with both limits specified in kHz.
	4. \"Sampling Rate\" \[RightArrow] specifies the sampling rate of the input IRs in Hz."

maxXCorrITD::usage=
"maxXCorrITD[inputHRIRLeft,inputHRIRRight] accepts two one-dimensional lists corresponding to the left and right HRIRs for a given individual and spatial location and computes the ITD, in seconds, as a deviation from zero seconds where the maximum of the cross-correlation of the left and right HRIRs occurs assuming a sampling rate of 44.1 kHz.

OPTIONAL INPUTS:
	1. \"Resampling\" \[RightArrow] specifies the factor by which to resample the input IRs prior to estimating ITD.
	2. \"Sampling Rate\" \[RightArrow] specifies the sampling rate of the input IRs in Hz."


pinnaSpectralNotches::usage=
"pinnaSpectralNotches[inputHRIR] identifies notches caused by the pinna in the magnitude spectrum corresponding to inputHRIR and returns the notch frequencies and their sample positions.

OPTIONAL INPUTS:
	1. \"Order\" \[RightArrow] specifies linear prediction residual order. (default = 12)
	2. \"Sampling Rate\" \[RightArrow] specifies the sampling rate in Hz. (default = 44100)

REF:
	1. Raykar et al. (2005) - Extracting the frequencies of the pinna spectral notches in measured HRIRs."

smoothHRTFLogMagSpec::usage=
"smoothHRTFLogMagSpec[inputHRIR] smooths the log-magnitude spectrum corresponding to inputHRIR and returns the smoothed, minimum-phase version of inputHRIR.

OPTIONAL INPUTS:
	1. \"Smoothing Factor\" \[RightArrow] specifies the smoothing factor to use. Values range between 0 (max. smoothing) and 1 (no smoothing). (default = 0.2)

REF:
	1. Kulkarni and Colburn (1998) - Role of spectral detail in sound localization."


Begin["`Private`"]


lowFreqSHMITD[azimuthAngle_,headRadius_: 0.0875]:=Module[
{azimuthAngleList,computedITDList,computedITD,soundSpeed=343}
,
If[ListQ[azimuthAngle],
azimuthAngleList=azimuthAngle;
,
azimuthAngleList=List[azimuthAngle];
];
computedITDList=(3. headRadius Sin[azimuthAngleList])/soundSpeed;
If[ListQ[azimuthAngle],
computedITD=computedITDList;
,
computedITD=computedITDList[[1]];
];
computedITD
]

highFreqSHMITD[azimuthAngleRad_,headRadiusMeter_: 0.0875]:=Module[
{azimuthAngleListRad,azimuthAngleListLen,computedITDListSec,computedITDSec,soundSpeed=343}
,
If[ListQ[azimuthAngleRad],
azimuthAngleListRad=azimuthAngleRad;
,
azimuthAngleListRad=List[azimuthAngleRad];
];
azimuthAngleListLen=Length[azimuthAngleListRad];
computedITDListSec=headRadiusMeter (Sin[azimuthAngleListRad]+azimuthAngleListRad)/soundSpeed ;
If[ListQ[azimuthAngleRad],
computedITDSec=computedITDListSec;
,
computedITDSec=computedITDListSec[[1]];
];
computedITDSec
]

Options[onsetITD]={"Resampling"->1,"Threshold"->20,"Sampling Rate"->44100};
onsetITD[inputHRIRLeft_,inputHRIRRight_,OptionsPattern[]]:=Module[
{resampleFactor,thresholdPercent,leftOnsetSample,rightOnsetSample,thresholdITDSec}
,
resampleFactor=OptionValue["Resampling"];
thresholdPercent=OptionValue["Threshold"];
leftOnsetSample= signalOnset[inputHRIRLeft,"Threshold"->thresholdPercent,"Resampling"->resampleFactor];
rightOnsetSample = signalOnset[inputHRIRRight,"Threshold"->thresholdPercent,"Resampling"->resampleFactor];
thresholdITDSec = 1./(resampleFactor OptionValue["Sampling Rate"]) (leftOnsetSample-rightOnsetSample)
]

Options[phaseDelayDifferenceITD]={"Averaged"->True,"Averaging Range"->{0.,0.5},"Resampling"->1,"Sampling Rate"->44100};
phaseDelayDifferenceITD[inputHRIRLeft_,inputHRIRRight_,OptionsPattern[]]:=Module[
{resampleFactor,samplingRate,averageITDFlag,averageRange,interpolatedHRIRLeft,interpolatedHRIRRight,interpolatedHRIRLen,phaseLeftRad,phaseRightRad,freqListHz,averagingFreqIndex,lfSampleIndex,hfSampleIndex,phaseDelayDifferenceITDSec,upsampledPhaseDelayDifferenceITDSec}
,
resampleFactor=OptionValue["Resampling"];
samplingRate=OptionValue["Sampling Rate"];
averageITDFlag=OptionValue["Averaged"];
averageRange=OptionValue["Averaging Range"];
interpolatedHRIRLeft=resample[inputHRIRLeft,1,resampleFactor];
interpolatedHRIRRight=resample[inputHRIRRight,1,resampleFactor];
interpolatedHRIRLen=Length[interpolatedHRIRLeft];
phaseLeftRad=unwrapPhase[Arg[Fourier[interpolatedHRIRLeft,FourierParameters->{1, -1}]]];
phaseRightRad=unwrapPhase[Arg[Fourier[interpolatedHRIRRight,FourierParameters->{1, -1}]]];
freqListHz=Range[1./interpolatedHRIRLen,1.,1./interpolatedHRIRLen] resampleFactor samplingRate;
If[averageITDFlag,
averagingFreqIndex=IntegerPart[(2./interpolatedHRIRLen+(averageRange 1000.)/(resampleFactor samplingRate)) interpolatedHRIRLen];
lfSampleIndex=averagingFreqIndex[[1]];
hfSampleIndex=averagingFreqIndex[[2]];
phaseDelayDifferenceITDSec=(1./(hfSampleIndex-lfSampleIndex)) Total[(phaseRightRad[[lfSampleIndex;;hfSampleIndex]]-phaseLeftRad[[lfSampleIndex;;hfSampleIndex]])/(2. N[\[Pi]] freqListHz[[lfSampleIndex;;hfSampleIndex]])];
,
upsampledPhaseDelayDifferenceITDSec=N[(phaseRightRad-phaseLeftRad)/(2. N[\[Pi]] freqListHz)];
phaseDelayDifferenceITDSec=Downsample[upsampledPhaseDelayDifferenceITDSec,resampleFactor];
];
phaseDelayDifferenceITDSec
]

Options[groupDelayDifferenceITD]={"Averaged"->True,"Averaging Range"->{0.,0.5},"Resampling"->1,"Sampling Rate"->44100};
groupDelayDifferenceITD[inputHRIRLeft_,inputHRIRRight_,OptionsPattern[]]:= Module[
{resampleFactor,sampleRateHz,averageITD,averagingFreqRangekHz,interpolatedHRIRLeft,interpolatedHRIRRight,interpolatedHRIRLen,groupDelayLeftSample, groupDelayRightSample,averagingFreqSampleIndex,lfSampleIndex,hfSampleIndex,groupDelayDifferenceITDSec,upsampledGroupDelayDifferenceITDSec}
,
resampleFactor=OptionValue["Resampling"];
sampleRateHz=OptionValue["Sampling Rate"];
averageITD=OptionValue["Averaged"];
averagingFreqRangekHz=OptionValue["Averaging Range"];
interpolatedHRIRLeft=resample[inputHRIRLeft,1,resampleFactor];
interpolatedHRIRRight=resample[inputHRIRRight,1,resampleFactor];
interpolatedHRIRLen=Length[interpolatedHRIRLeft];
groupDelayLeftSample=Re[Quiet[Fourier[Range[interpolatedHRIRLen] interpolatedHRIRLeft,FourierParameters->{1, -1}]/Fourier[interpolatedHRIRLeft,FourierParameters->{1, -1}]]/.ComplexInfinity->0];
groupDelayRightSample=Re[Quiet[Fourier[Range[interpolatedHRIRLen] interpolatedHRIRRight,FourierParameters->{1, -1}]/Fourier[interpolatedHRIRRight,FourierParameters->{1, -1}]]/.ComplexInfinity->0];
If[averageITD,
averagingFreqSampleIndex=IntegerPart[(1./interpolatedHRIRLen+(averagingFreqRangekHz 1000.)/(resampleFactor sampleRateHz))interpolatedHRIRLen];
lfSampleIndex=averagingFreqSampleIndex[[1]];
hfSampleIndex=averagingFreqSampleIndex[[2]];
groupDelayDifferenceITDSec=N[(1/(hfSampleIndex-lfSampleIndex) Total[groupDelayLeftSample[[lfSampleIndex;;hfSampleIndex]]-groupDelayRightSample[[lfSampleIndex;;hfSampleIndex]]]) (1./(resampleFactor sampleRateHz))];
,(* ELSE *)
upsampledGroupDelayDifferenceITDSec=N[(groupDelayLeftSample-groupDelayRightSample)/(resampleFactor sampleRateHz)];
groupDelayDifferenceITDSec=Downsample[upsampledGroupDelayDifferenceITDSec,resampleFactor];
];
groupDelayDifferenceITDSec
]

Options[maxXCorrITD]={"Resampling"->1,"Sampling Rate"->44100};
maxXCorrITD[inputHRIRLeft_,inputHRIRRight_,OptionsPattern[]]:=Module[
{resampleFactor,sampleRateHz,interpolatedHRIRLeft,interpolatedHRIRRight,leftHRIREnergy,rightHRIREnergy,normalizationFactor,normalizedCrossCorrelationLRList,normalizedCrossCorrelationRLList,maxPosLR,maxPosRL,samplesITD,maxCrossCorrelationITDSec}
,
resampleFactor=OptionValue["Resampling"];
sampleRateHz=OptionValue["Sampling Rate"];
interpolatedHRIRLeft=resample[inputHRIRLeft,1,resampleFactor];
interpolatedHRIRRight=resample[inputHRIRRight,1,resampleFactor];
leftHRIREnergy = ListCorrelate[interpolatedHRIRLeft,interpolatedHRIRLeft,{1,1}][[1]];
rightHRIREnergy = ListCorrelate[interpolatedHRIRRight,interpolatedHRIRRight,{1,1}][[1]];
normalizationFactor=Sqrt[leftHRIREnergy rightHRIREnergy];
normalizedCrossCorrelationLRList = ListCorrelate[interpolatedHRIRLeft,interpolatedHRIRRight,{1,1}]/normalizationFactor;
normalizedCrossCorrelationRLList = ListCorrelate[interpolatedHRIRRight,interpolatedHRIRLeft,{1,1}]/normalizationFactor;
maxPosLR = FirstPosition[normalizedCrossCorrelationLRList,Max[normalizedCrossCorrelationLRList]][[1]];
maxPosRL = FirstPosition[normalizedCrossCorrelationRLList,Max[normalizedCrossCorrelationRLList]][[1]];
samplesITD=Min[maxPosLR,maxPosRL];
If[maxPosLR>=maxPosRL,maxCrossCorrelationITDSec=1./(resampleFactor sampleRateHz) (samplesITD-1.);
, (* ELSE *)
maxCrossCorrelationITDSec=-(1./(resampleFactor sampleRateHz))(samplesITD-1.);
];
maxCrossCorrelationITDSec
]

Options[pinnaSpectralNotches]={"Order"->12,"Sampling Rate"->44100};
pinnaSpectralNotches[inputHRIR_]:=Module[
{onsetSamp,inputIRLen,shiftIR,lpResOrder,lpResIR,fS,winLen,halfHannWin,winLPRes,acf,winAutoCorrFunc,grpDelFunc,fVec,nyqSamp,grpDelFuncFlip,specNotchSamps,specNotchFreqs}
,
onsetSamp=signalOnset[inputHRIR];
inputIRLen=Length[inputHRIR];
shiftIR=PadRight[inputHRIR[[onsetSamp;;]],inputIRLen];
lpResOrder=OptionValue["Order"];
fS=OptionValue["Sampling Rate"];
lpResIR=lpResidual[shiftIR,lpResOrder];
winLen=Round[fS/1000];
halfHannWin=PadRight[raisedCosWin[winLen,{0,1}],inputIRLen];
winLPRes=lpResIR halfHannWin;
acf=autoCorrFunc[winLPRes];
winAutoCorrFunc=acf halfHannWin;
grpDelFunc=groupDelaySpec[winAutoCorrFunc];
grpDelFuncFlip=Mean[grpDelFunc]-grpDelFunc;
nyqSamp=Ceiling[(inputIRLen+1)/2];
specNotchSamps=PeakDetect[grpDelFuncFlip[[;;nyqSamp]],0,0,-\[Infinity]];
fVec=freqList[inputIRLen,fS];
specNotchFreqs=Pick[fVec[[;;nyqSamp]],specNotchSamps,1];
{specNotchFreqs,Pick[Range[nyqSamp],specNotchSamps,1]}
]

Options[smoothHRTFLogMagSpec]={"Smoothing Factor"->0.2};
smoothHRTFLogMagSpec[inputHRIR_]:=Module[
{inputHRTF,inputHRTFLen,inputHRTFNyqLen, logMagHRTF,alpha,fourierSeriesCoeffs,smoothingFactor,smoothingIndex,smoothedHRTFHalf,smoothedHRTF,zeroPhIR,minPhIR}
,
inputHRTF=Fourier[inputHRIR,FourierParameters->{1,-1}];
inputHRTFLen=Length[inputHRTF];
inputHRTFNyqLen = Ceiling[(inputHRTFLen+1)/2];
logMagHRTF=Log10[Abs[inputHRTF]];
alpha = Join[{0.5},ConstantArray[1,inputHRTFNyqLen-2],{0.5}];
fourierSeriesCoeffs=2 alpha (1/Sqrt[2(inputHRTFNyqLen-1)]) FourierDCT[logMagHRTF[[;;inputHRTFNyqLen]],1];
smoothingFactor=OptionValue["Smoothing Factor"];
smoothingIndex=IntegerPart[smoothingFactor inputHRTFNyqLen];
smoothingIndex=Clip[smoothingIndex,{1,inputHRTFNyqLen}];
smoothedHRTFHalf=Table[Total[fourierSeriesCoeffs[[;;smoothingIndex]] Cos[(2\[Pi] (ii-1))/inputHRTFLen Range[0,smoothingIndex-1]]],{ii,inputHRTFNyqLen}];
smoothedHRTF=10^(Join[smoothedHRTFHalf,Drop[Reverse[Drop[smoothedHRTFHalf,1]],1]]);
zeroPhIR=Re[InverseFourier[smoothedHRTF,FourierParameters->{1,-1}]];
minPhIR=PadRight[minPhaseIR[zeroPhIR],Length[inputHRIR]]
]


End[]


EndPackage[]

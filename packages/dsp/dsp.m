(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["dsp`",{"general`"}]


applyButterHPF::usage="applyButterHPF[x,filterOrder,Wn] applies a Butterworth high-pass filter of order filterOrder and cut-off frequency Wn to the input signal x. The output is the filtered signal."

applyButterLPF::usage="applyButterLPF[x,filterOrder,Wn] applies a Butterworth low-pass filter of order filterOrder and cut-off frequency Wn to the input signal x. The output is the filtered signal."

autoCorrFunc::usage="autoCorrFunc[signal] computes the autocorrelation function of signal.

OPTIONAL INPUTS:
	1. rectWinLen \[RightArrow] Sample length of the rectangular window to apply to signal.
	Default - Length[signal].
EXAMPLE: 
	output = autoCorrFunc[signal,100];
REF:
	Makhoul (1975) - Linear Prediction: A Tutorial Review."

avgGroupDelay::usage="avgGroupDelay[inputIR,fS] computes the DC group delay, in samples, of inputIR sampled at a rate fS.

OPTIONAL INPUTS:
	1. avgRange \[RightArrow] Frequencies over which group delay is averaged; {0,0} - default.
EXAMPLE: 
	grpDel = avgGroupDelay[inputIR,44100,{0, 500}];"

conv::usage="conv[x,y] convolves x with y.

OPTIONAL INPUTS:
	1. type \[RightArrow] specifies the type of convolution to perform.
	\"circ\" (default) - circular convolution; input sequences must be of same length.
	\"lin\" - linear convolution; output length = Length[x+y-1].
EXAMPLE:
	output = conv[x,y,\"circ\"];"

deconv::usage="deconv[y,x] deconvolves y by x and outputs a signal with the same length as y."

groupDelaySpec::usage="groupDelaySpec[inputIR] returns the group delay spectrum of inputIR."

IRtoTF::usage="IRtoTF[IR] outputs the transfer function corresponding to the input impulse response (IR)."

KaiserLPFIR::usage="KaiserLPFIR[irLen,pbCutoff,sbCutoff] generates a Kaiser window low-pass filter IR of length irLen and with passband and stopband normalized cutoff frequencies pbCutoff and sbCutoff specified in rad, respectively.

OPTIONAL INPUTS:
	1. \"PB Gain\" \[RightArrow] minimum passband gain in dB (default -1).
	2. \"SB Gain\" \[RightArrow] maximum stopband gain in dB (default -30).
EXAMPLE:
	lpfIR = KaiserLPFIR[1024,0.5\[Pi],0.6\[Pi],\"SB Gain\" \[RightArrow] -40];"

lpResidual::usage="lpResidual[signal,p] computes the linear prediction residual of signal. The order of the predictor is specified by p.

REF:
	Makhoul (1975) - Linear Prediction: A Tutorial Review."

minPhaseIR::usage="minPhaseIR[inputIR] computes the minimum-phase component of inputIR."

raisedCosWin::usage="raisedCosWin[winLen] generates a raised-cosine window of length winLen.

OPTIONAL INPUTS:
	1. r \[RightArrow] Ordered pair of fractions of samples equal to parts of an attack and decay cosine;
	0 \[LessEqual] r(i) \[LessEqual] 1, i = 1,2; r = {0,0} - rect.; r = {0.5,0.5} - hann.; r = {0.25,0.25} - default.
EXAMPLE: 
	winList = raisedCosWin[100,{0.2,0.3}];"

resample::usage="resample[inputSignal,inputSR,outputSR] uses bandlimited interpolation to generate an output signal with outputSR/inputSR times the number of samples as inputSignal. A Kaiser window low-pass anti-aliasing filter is applied."

signalOnset::usage="signalOnset[inputSignal] computes the onset sample of inputSignal as the first sample value at which inputSignal is at least 20% of its absolute maximum.

OPTIONAL INPUTS:
	1. \"Threshold\" \[RightArrow] specifies the threshold percentage to use instead of the default 20%.
	2. \"Resampling\" \[RightArrow] resampling factor by which inputSignal is first resampled.
EXAMPLE:
	onsetSample = signalOnset[inputSignal,\"Threshold\" \[RightArrow] 10,\"Resampling\" \[RightArrow] 4];"

TFtoIR::usage="TFtoIR[TF] outputs the impulse response corresponding to the input transfer function (TF)."

tukeyWin::usage="tukeyWin[winLen] generates a Tukey window of length winLen.

OPTIONAL INPUTS:
	1. r \[RightArrow] Fraction of samples equal to parts of a cosine.
	0 \[LessEqual] r \[LessEqual] 1; r = 0 (rect.); r = 1 (hann.); r = 0.5 (default)
EXAMPLE:
	winList = tukeyWin[100,1];"

unwrapPhase::usage="unwrapPhase[inputPhase] unwraps inputPhase.

OPTIONAL INPUTS:
	1. tol \[RightArrow] phase wrapping tolerance; default - \[Pi].
EXAMPLE: 
	unwrappedPhase = unwrapPhase[inputPhase,2\[Pi]];"

inverseFilter::usage="inverseFilter[h] computes the impulse response of the inverse filter corresponding to the input impulse response, h.

OPTIONAL INPUTS:
	1. \"Regularization\" \[RightArrow] specifies the type of regularization to apply with \"None\" (default) and \"Piecewise\" being the two options.
	2. \"Regularization Ranges\" \[RightArrow] list of triples {W1, W2, \[Epsilon]} which specifies the regularization parameter \[Epsilon] in the range {W1, W2}.
EXAMPLE:
	invFilt = inverseFilter[filt,\"Regularization\"\[Rule]\"Piecewise\",\"Regularization Ranges\"\[Rule]{{0,0.1,0.001},{0.2,1,0}}];"

piecewiseRegularization::usage="piecewiseRegularization[N,\[Epsilon]List] returns a piecewise regularization profile of length N and regularization ranges specifed by \[Epsilon]List. For more about \[Epsilon]List, see the function description for inverseFilter[]."

HatzOctaveSmoothPS::usage=
"HatzOctaveSmoothPS[inputPowerSpectrum] returns a one-third octave smoothed version of the input power spectrum using a Hanning window for smoothing. The input must be a power spectrum. The algorithm used is described in Hatziantoniou, Panagiotis D., and John N. Mourjopoulos. \"Generalized fractional-octave smoothing of audio and acoustic responses.\" Journal of the Audio Engineering Society 48.4 (2000): 259-280.

OPTIONAL INPUTS:
	1. \"Smoothing Factor\" \[RightArrow] specifies the denominator of the fraction used to specify the amount of smoothing to apply. For example, specifying 3 performs one-third octave smoothing.
	2. \"Window\" \[RightArrow] specifies the type of smoothing window to use. The options are \"Rectangular\", \"Hanning\", and \"Hamming\"."

discreteAnalyticSignal::usage=
"discreteAnalyticSignal[inputSignal] returns the discrete analytic version of inputSignal."

envelopeSignal::usage=
"envelopeSignal[inputSignal] returns the positive and negative envelopes of inputSignal as a two-dimensional list with the first dimension containing the positive envelope."

HilbertTransform::usage=
"HilbertTransform[inputSignal] computes the Hilbert transform of inputSignal."

getAllPassIR::usage=
"getAllPassIR[inputIR] accepts a one-dimensional list corresponding to the causal FIR of a linear system with arbitrary phase and computes its corresponding excess-phase version. The output is a one-dimensional list of length equal to that of the input list."

getMinimumPhaseIR::usage=
"getMinimumPhaseIR[inputIR] accepts a one-dimensional list corresponding to the causal FIR of a linear system with arbitrary phase and computes its corresponding minimum-phase version. The output is a one-dimensional list of length equal to that of the input list."

realCepstrum::usage=
"realCepstrum[inputSignal] accepts a one-dimensional list and computes its real cepstrum. The output is a one-dimensional list of real numbers of the same length as the input."

getBalancedIR::usage=
"getBalancedIR[inputIR] returns the balanced realization of inputIR.

OPTIONAL INPUTS:
	1. \"Order\" \[RightArrow] specifies the order of the balanced IR. This must be between 1 and the length of inputIR in samples. (default = length of inputIR)
	2. \"Sampling Rate\" \[RightArrow] specifies the sampling rate in Hz. (default = 44100)

REF:
	1. Beliczynski et al. (1992) - Approximation of FIR by IIR Digital Filters: An Algorithm Based on Balanced Model Reduction."

getSPLNorm::usage=
"getSPLNorm[refSPL] returns the normalization factor required to normalize transfer functions to represent magnitude responses in dB SPL. The required input to the function, refSPL, must specify the SPL corresponding to 0 dBFS. In the 3D3A Lab at Princeton University, the typical calibration results in 94 dBSPL corresponding to -11 dBFS, giving a refSPL value of 105 dB. If refSPL is not specified, 105 dB is assumed."


Begin["`Private`"]


applyButterHPF[x_,filterOrder_,Wn_]:=Module[{IRLen,xp,W,HPF,y},
IRLen = Length[x];
xp = RotateRight[PadRight[x,2IRLen],IRLen/2];
W = N[Join[Range[0,IRLen],Reverse[Range[1,IRLen-1]]]/IRLen];
HPF = 1-1/Sqrt[1+(W/Wn)^(2filterOrder)];
y = RotateLeft[TFtoIR[IRtoTF[xp]HPF],IRLen/2][[;;IRLen]]
]

applyButterLPF[x_,filterOrder_,Wn_]:=Module[{IRLen,xp,W,LPF,y},
IRLen = Length[x];
xp = RotateRight[PadRight[x,2IRLen],IRLen/2];
W = N[Join[Range[0,IRLen],Reverse[Range[1,IRLen-1]]]/IRLen];
LPF = 1/Sqrt[1+(W/Wn)^(2filterOrder)];
y = RotateLeft[TFtoIR[IRtoTF[xp]LPF],IRLen/2][[;;IRLen]]
]

autoCorrFunc[signal_,rectWinLen_: 0]:=Module[
{signalLen,acf}
,
If[rectWinLen==0,
signalLen=Length[signal];
,
signalLen=Clip[rectWinLen,{1, Length[signal]}];
];
acf=ConstantArray[0,signalLen];
Do[
acf[[ii]]=Total[Drop[signal RotateLeft[signal,ii-1],-(ii-1)]];
,
{ii,1,signalLen}
];
acf
]

avgGroupDelay[inputIR_,fS_,avgRange_:{0,0}]:=Module[
{inputIRLen,fVec,avgR,avgRL,avgRR,fIndices,grpDSpec,avgGrpDel}
,
inputIRLen=Length[inputIR];
fVec=freqList[inputIRLen,fS];
avgR=Clip[avgRange,{0, fS/2}];
avgRL=Nearest[fVec,Min[avgR]];
avgRR=Nearest[fVec,Max[avgR]];
fIndices=Flatten[Position[fVec,avgRL[[1]]|avgRR[[1]]]];
grpDSpec=groupDelaySpec[inputIR];
If[Length[fIndices]==1,
avgGrpDel=grpDSpec[[fIndices[[1]]]];
,
avgGrpDel=Mean[grpDSpec[[Min[fIndices];;Max[fIndices]]]];
];
Round[avgGrpDel]
]

conv[x_,y_,type_:"circ"]:=Module[
{yLen,xLen,output,padLen,yPad,xPad,outputPad}
,
yLen=Length[y];
xLen=Length[x];
If[type=="circ",
If[xLen==yLen,
output=TFtoIR[IRtoTF[x] IRtoTF[y]];
,
MessageDialog["Sequences must be of the same length."];
Abort[];
]
,
padLen=nextPowTwo[xLen+yLen-1];
yPad=PadRight[y,padLen];
xPad=PadRight[x,padLen];
outputPad=TFtoIR[IRtoTF[xPad] IRtoTF[yPad]];
output=outputPad[[;;xLen+yLen-1]];
];
output
]

deconv[y_,x_,type_:"circ"]:=Module[
{yLen,xLen,padLen,yPad,xPad,outputPad,output}
,
yLen=Length[y];
xLen=Length[x];
If[type=="circ",
If[xLen==yLen,
output=TFtoIR[Quiet[IRtoTF[y]/ IRtoTF[x]]/.ComplexInfinity->(0.+0. I)];
,
MessageDialog["Sequences must be of the same length."];
Abort[];
]
,
padLen=nextPowTwo[xLen+yLen-1];
yPad=PadRight[y,padLen];
xPad=PadRight[x,padLen];
outputPad=TFtoIR[Quiet[IRtoTF[yPad]/IRtoTF[xPad]]/.ComplexInfinity->(0.+0. I)];
output=outputPad[[;;yLen]]
];
output
]

groupDelaySpec[inputIR_]:=Module[
{inputIRLen,ramp,grpDSpec}
,
inputIRLen=Length[inputIR];
ramp=Range[0,inputIRLen-1];
grpDSpec=Re[IRtoTF[inputIR ramp]/(Chop[N[IRtoTF[inputIR]]]/.{0->\[Infinity]})]
]

IRtoTF[IR_]:=Fourier[IR,FourierParameters->{1,-1}]

Options[KaiserLPFIR]={"PB Gain"->-1,"SB Gain"->-30};
KaiserLPFIR[irLen_,pbCutoff_,sbCutoff_,OptionsPattern[]]:=Module[
{\[Delta]1,\[Delta]2,\[Delta],\[Omega]c,d\[Omega],A,\[Beta],M,filterLen,\[Alpha],filterIR}
,
\[Delta]1=1-(10^(OptionValue["PB Gain"]/20));
\[Delta]2=10^(OptionValue["SB Gain"]/20);
\[Delta]=Min[\[Delta]1,\[Delta]2];
\[Omega]c=(pbCutoff+sbCutoff)/2;
d\[Omega]=sbCutoff-pbCutoff;
A=-20Log10[\[Delta]];
If[A>50,
\[Beta]=0.1102 (A-8.7);
,
If[A>=21&&A<=50,
\[Beta]=0.5842 (A-21)^0.4+0.07886 (A-21);
,
\[Beta]=0;
]
];
M=Round[(A-8)/(2.285 d\[Omega])];
filterLen=irLen;
If[filterLen<(M+1),
filterLen=M+1;
];
\[Alpha]=M/2;
filterIR=ConstantArray[0,filterLen];
filterIR[[;;M+1]]=Sinc[\[Omega]c (Range[0,M]-\[Alpha])](\[Omega]c/\[Pi])(BesselI[0,N[\[Beta]] Sqrt[1-((Range[0,M]-\[Alpha])/\[Alpha])^2]]/BesselI[0,N[\[Beta]]]);
filterIR
]

lpResidual[signal_,p_]:=Module[
{autoCorrList,autoCorrMat,aVec,lpRes,predVec}
,
autoCorrList=autoCorrFunc[signal,p+1];
autoCorrMat=ToeplitzMatrix[autoCorrList[[2;;]]];
aVec=Inverse[autoCorrMat].(-autoCorrList[[2;;]]);
lpRes=signal;
predVec=LowerTriangularize[ToeplitzMatrix[signal[[;;-2]]]].PadRight[aVec,Length[signal]-1];
lpRes[[2;;]]=signal[[2;;]]+predVec;
lpRes
]

minPhaseIR[inputIR_]:=Module[
{irLen,padIRLen,padIR,padRCeps,win,padIRHalfLen,minPhasePadIR,minPhaseIR}
,
irLen=Length[inputIR];
padIRLen=nextPowTwo[irLen];
padIR=PadRight[inputIR,padIRLen];
padRCeps=TFtoIR[Log[Abs[IRtoTF[padIR]]]];
win=ConstantArray[0,padIRLen];
padIRHalfLen=padIRLen/2;
win[[1]]=1;
win[[2;;padIRHalfLen-1]]=2;
win[[padIRHalfLen]]=1;
minPhasePadIR=TFtoIR[Exp[IRtoTF[win padRCeps]]];
minPhaseIR=minPhasePadIR[[;;irLen]]
]

raisedCosWin[winLen_,r_: {0.25,0.25}]:=Module[
{x,winVec,rFinal}
,
x=Range[0,1-(1/winLen),(1/winLen)];
winVec=ConstantArray[1,winLen];
rFinal=Clip[Abs[r],{0,1}];
If[Mean[rFinal]>0.5,
rFinal=Clip[rFinal,{0,Clip[Min[rFinal],{0,0.5}]}];
];
If[rFinal[[1]]!=0,
winVec[[;;Round[winLen rFinal[[1]]]]]=0.5(1+Cos[Pi/rFinal[[1]] (x[[;;Round[winLen rFinal[[1]]]]]-rFinal[[1]])]);
];
If[rFinal[[2]]!=0,
winVec[[winLen-Round[winLen rFinal[[2]]]+1;;]]=0.5(1+Cos[Pi/rFinal[[2]] (x[[winLen-Round[winLen rFinal[[2]]]+1;;]]-1+rFinal[[2]])]);
];
winVec
]

resample[inputSignal_,inputSR_,outputSR_]:= Module[
{rationalR,outputSignal,L,M,inputSignalLen,upsampSignal,upsampSigLen,cutoff,lpfIR,lpfIRDel,lpfIRLen,maxLen,upsampSignalPad,lpfIRPad,delCompLPFIRPad,interpSignal},
rationalR=Rationalize[outputSR/inputSR];
If[rationalR == 1,
outputSignal=inputSignal;
,
L=Numerator[rationalR];
M=Denominator[rationalR];
inputSignalLen=Length[inputSignal];
upsampSignal=Upsample[inputSignal,L];
upsampSigLen=Length[upsampSignal];
cutoff=Min[Pi/L,Pi/M];
lpfIR=L KaiserLPFIR[upsampSigLen,0.95cutoff,cutoff,"SB Gain"->-60];
lpfIRDel=avgGroupDelay[lpfIR,inputSR L];
lpfIRLen=Length[lpfIR];
maxLen=Max[upsampSigLen,lpfIRLen];
upsampSignalPad=PadRight[upsampSignal,maxLen];
lpfIRPad=PadRight[lpfIR,maxLen];
delCompLPFIRPad=RotateLeft[lpfIRPad,lpfIRDel];
interpSignal=conv[upsampSignalPad,delCompLPFIRPad];
outputSignal=Downsample[interpSignal[[;;upsampSigLen]],M];
];
outputSignal
]

Options[signalOnset]={"Threshold"->20,"Resampling"->1};
signalOnset[inputSignal_,OptionsPattern[]]:=Module[
{resampling,interpSignal,threshold,onsetSample}
,
resampling=OptionValue["Resampling"];
interpSignal=resample[inputSignal,1,resampling];
threshold = (OptionValue["Threshold"]/100) Max[Abs[interpSignal]];
onsetSample = Position[interpSignal,_?(Abs[#]>=threshold &)][[1,1]]/resampling
]

TFtoIR[TF_]:=Re[InverseFourier[TF,FourierParameters->{1,-1}]]

tukeyWin[winLen_,r_: 0.5]:=Module[
{x,winVec}
,
x=Range[0,1-(1/winLen),(1/winLen)];
winVec=ConstantArray[1,winLen];
If[r!=0,
winVec[[;;Round[winLen r/2]]]=0.5(1+Cos[(2Pi)/r (x[[;;Round[winLen r/2]]]-r/2)]);
winVec[[winLen-Round[winLen r/2]+1;;]]=0.5(1+Cos[(2Pi)/r (x[[winLen-Round[winLen r/2]+1;;]]-1+r/2)]);
];
winVec
]

unwrapPhase[inputPhase_,tol_: \[Pi]] := Module[
{inputPhaseLen,unwrappedPhase}
,
inputPhaseLen=Length[inputPhase];
unwrappedPhase=inputPhase;
Do[
If[(inputPhase[[ii+1]]-inputPhase[[ii]]>=tol),
unwrappedPhase[[ii+1;;]]=unwrappedPhase[[ii+1;;]]-2 tol;
]
,
{ii,1,inputPhaseLen-1}
];
unwrappedPhase
]

Options[inverseFilter]={"Regularization"->"None","Regularization Ranges"->{{0,1,0}}};
inverseFilter[h_,OptionsPattern[]]:=Module[{IRLen,H,z,\[Epsilon]},
IRLen = Length[h];
H = IRtoTF[h];
Switch[OptionValue["Regularization"],
"None",
z = TFtoIR[1/H];
,
"Piecewise",
\[Epsilon] = piecewiseRegularization[IRLen,OptionValue["Regularization Ranges"]];
z = TFtoIR[Conjugate[H]/(Conjugate[H]H+\[Epsilon])];
];
z
]

piecewiseRegularization[N_,\[Epsilon]List_ ]:=Module[{regPoints,regFn,regHalf},
regPoints = DeleteDuplicates[Flatten[Table[{{\[Epsilon]List[[ii,1]],\[Epsilon]List[[ii,3]]},{\[Epsilon]List[[ii,2]],\[Epsilon]List[[ii,3]]}},{ii,1,Length[\[Epsilon]List]}],1]];
regFn = Interpolation[regPoints,InterpolationOrder->1];
regHalf = regFn[Range[0,1,2/N]];
Join[regHalf,Reverse[regHalf[[2;;-2]]]]
]

Options[HatzOctaveSmoothPS]={"Smoothing Factor"->3,"Window"->"Hanning"};
HatzOctaveSmoothPS[inputPowerSpectrum_,OptionsPattern[]]:=Module[
{powerSpectrumLen,nyqIndex,oSFrac,oSWinType,Pf,mk,mkMax,b,Wsm,smoothedPSHalf,smoothedPS}
,
powerSpectrumLen=Length[inputPowerSpectrum];
nyqIndex=Ceiling[(powerSpectrumLen+1)/2];
oSFrac=OptionValue["Smoothing Factor"];
oSWinType=OptionValue["Window"];
Pf = 2^(0.5/oSFrac)-0.5^(0.5/oSFrac);
mk=IntegerPart[(Range[nyqIndex]-1)/2 Pf];
mk=Clip[mk,{1,nyqIndex-1}];
mkMax=Max[mk];
Switch[oSWinType,
"Rectangular",
b = 1;
,"Hanning",
b = 0.5;
,"Hamming",
b = 0.54;
];
Wsm=ConstantArray[0,{mkMax,powerSpectrumLen}];
Do[
Wsm[[m,1;;m+1]]=(b-(b-1)Cos[(\[Pi]/m)(Range[-m,0])])/(2 b (m+1) -1);
Wsm[[m,m+2;;2m+1]]=(b-(b-1)Cos[(\[Pi]/m)(Range[2,m+1]-1)])/(2 b (m+1) -1);
,
{m,1,mkMax}
];
smoothedPSHalf=inputPowerSpectrum[[1;;nyqIndex]];
smoothedPSHalf[[2;;nyqIndex-1]]=Table[Total[inputPowerSpectrum[[ii-mk[[ii]];;ii+mk[[ii]]]] Wsm[[mk[[ii]],1;;(2mk[[ii]]+1)]]],{ii,2,nyqIndex-1}];
smoothedPS=Join[smoothedPSHalf,Reverse[Conjugate[smoothedPSHalf[[2;;-2]]]]]
]

discreteAnalyticSignal[inputSignal_] := Module[
{inputSignalReal,inputSignalRealDFT,inputSignalRealLength,inputSignalRealHalfLength,hilbertDFT,outputSignal}
,
inputSignalReal=Re[inputSignal];inputSignalRealDFT=Fourier[inputSignalReal,FourierParameters->{1, -1}];inputSignalRealLength=Length[inputSignalReal];inputSignalRealHalfLength=Ceiling[(inputSignalRealLength+1)/2];hilbertDFT=ConstantArray[0,inputSignalRealLength];If[EvenQ[inputSignalRealLength],
hilbertDFT[[1]]=1;
hilbertDFT[[2;;inputSignalRealHalfLength-1]]=2;hilbertDFT[[inputSignalRealHalfLength]]=1;
, 
hilbertDFT[[1]]=1;
hilbertDFT[[2;;inputSignalRealHalfLength]]=2;
];
outputSignal=InverseFourier[inputSignalRealDFT hilbertDFT,FourierParameters->{1, -1}]
]

envelopeSignal[inputSignal_]:=Module[
{positiveEnvelope,negativeEnvelope,outputSignal}
,
positiveEnvelope=Chop[Abs[discreteAnalyticSignal[inputSignal]]];
negativeEnvelope=-positiveEnvelope;
outputSignal={positiveEnvelope,negativeEnvelope}
]

HilbertTransform[inputSignal_] := Module[
{dAnalyticSignal,outputSignal}
,
dAnalyticSignal=discreteAnalyticSignal[inputSignal];
outputSignal=Im[dAnalyticSignal]
]

getAllPassIR[inputIR_] := Module[
{inputIRLen,inputIRHalfLen,inputTFMag,inputTFPhase,evenPartIR,oddPartIR,minPhaseResponse,outputIR}
,
inputIRLen=Length[inputIR];
inputIRHalfLen=Ceiling[inputIRLen/2];
inputTFMag=Abs[Fourier[inputIR,FourierParameters->{1, -1}]];
inputTFPhase=Arg[Fourier[inputIR,FourierParameters->{1, -1}]];
evenPartIR=Re[InverseFourier[Log[inputTFMag],FourierParameters->{1, -1}]];
oddPartIR=ConstantArray[0,inputIRLen];
oddPartIR[[2;;inputIRHalfLen]]=evenPartIR[[2;;inputIRHalfLen]];
If[EvenQ[inputIRLen],
oddPartIR[[inputIRHalfLen+2;;]]=-evenPartIR[[inputIRHalfLen+2;;]];
,
oddPartIR[[inputIRHalfLen+1;;]]=-evenPartIR[[inputIRHalfLen+1;;]];
];
minPhaseResponse=Im[Fourier[oddPartIR,FourierParameters->{1, -1}]];
outputIR=Re[InverseFourier[E^(\[ImaginaryJ] (inputTFPhase-minPhaseResponse)),FourierParameters->{1, -1}]]
]

getMinimumPhaseIR[inputIR_] := Module[
{inputIRLen,inputIRHalfLen,inputTFMag,evenPartIR,oddPartIR,minPhaseResponse,outputIR}
,
inputIRLen=Length[inputIR];
inputIRHalfLen=Ceiling[inputIRLen/2];
inputTFMag=Abs[Fourier[inputIR,FourierParameters->{1, -1}]];
evenPartIR=Re[InverseFourier[Log[inputTFMag],FourierParameters->{1, -1}]];
oddPartIR=ConstantArray[0,inputIRLen];
oddPartIR[[2;;inputIRHalfLen]]=evenPartIR[[2;;inputIRHalfLen]];
If[EvenQ[inputIRLen],
oddPartIR[[inputIRHalfLen+2;;]]=-evenPartIR[[inputIRHalfLen+2;;]];
,
oddPartIR[[inputIRHalfLen+1;;]]=-evenPartIR[[inputIRHalfLen+1;;]];
];
minPhaseResponse=Im[Fourier[oddPartIR,FourierParameters->{1, -1}]];
outputIR=Re[InverseFourier[inputTFMag E^(\[ImaginaryJ] minPhaseResponse),FourierParameters->{1, -1}]]
]

realCepstrum[inputSignal_] := Module[
{outputSignal}
,
outputSignal=Re[InverseFourier[Log[Abs[Fourier[inputSignal,FourierParameters->{1, -1}]]],FourierParameters->{1, -1}]]
]

Options[getBalancedIR]={"Order"->0,"Sampling Rate"->44100};
getBalancedIR[inputIR_,OptionsPattern[]]:=Module[
{iR,irLen,order,hankelMat,uMat,sigmaMat,vMat,hatA,hatB,hatC,hatD,fS,sys,sysIR}
,
iR=Join[{0},inputIR];
irLen=Length[iR];
order=OptionValue["Order"];
fS=OptionValue["Sampling Rate"];
If[order<=0,
order=irLen-1;
];
order=Min[order,irLen];
hankelMat=HankelMatrix[iR];
{uMat,sigmaMat,vMat}=SingularValueDecomposition[hankelMat];
hatA=Transpose[vMat[[2;;irLen,1;;order]]].vMat[[1;;(irLen-1),1;;order]];
hatB=Transpose[{vMat[[1,1;;order]]}];
hatC={iR.vMat[[1;;irLen,1;;order]]};
hatD={{0}};
sys=StateSpaceModel[{hatA,hatB,hatC,hatD},SamplingPeriod->1/fS];
sysIR=RotateLeft[Flatten[OutputResponse[sys,N[Join[{1},ConstantArray[0,Length[inputIR]-1]]]]]]
]

getSPLNorm[refSPL_: 105]:=10^(-refSPL/20.)


End[]


EndPackage[]
